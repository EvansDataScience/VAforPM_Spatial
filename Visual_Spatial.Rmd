<br> 
<center><img src="http://i.imgur.com/sSaOozN.png" width="500"></center>


## Course: VISUAL ANALYTICS FOR POLICY AND MANAGEMENT

### Prof. José Manuel Magallanes, PhD 
* Visiting Professor of Computational Policy at Evans School of Public Policy and Governance, and eScience Institute Senior Data Science Fellow, University of Washington.
* Professor of Government and Political Methodology, Pontificia Universidad Católica del Perú. 


_____


# Session 6: Spatial Data
_____


<a id='open'></a>

# Opening data files

Let's open this file that includes the democracy index, the human development index, adn the military expenditures  as share of gdp at the country level :
```{r}

linkCSV='https://github.com/EvansDataScience/VAforPM_Spatial/raw/main/merged_data.csv'

dataCSV=read.csv(linkCSV)
```

This is what you have:
```{r}
str(dataCSV)
```

Let's explore the behavior of each numerical variable:

```{r}
boxplot(dataCSV[,c('DemoIndex','HDI','mil_expend')])
```
The data ranges are different. We can try **standardization**:

```{r}
dataCSV$HDI_S=as.vector(scale(dataCSV$HDI))
dataCSV$DEM_S=as.vector(scale(dataCSV$DemoIndex))
dataCSV$MIL_S=as.vector(scale(dataCSV$mil_expend))
```

Let's cluster the data using **pam** again:

```{r}
#data to cluster

set.seed(123)

library(cluster)
vars=c('HDI_S','DEM_S','MIL_S')


distMatrix=cluster::daisy(dataCSV[,vars])
          
res.pam=cluster::pam(x=distMatrix,
                     k = 3,
                     cluster.only = F)

```

Let's save the cluster info into the data frame:

```{r}
dataCSV$cluster=as.factor(res.pam$clustering)
```

Check order:

```{r}
theVars=c('HDI_S','DEM_S','MIL_S','cluster')
aggregate(.~cluster,
          data=dataCSV[,theVars],
          FUN=median)
```

We could recode:

```{r}
dataCSV$cluster=factor(dataCSV$cluster,
                           levels=c(1,3,2),
                           labels=c("low","mid","best"), 
                           ordered=T)
```


Now let me open the map:


```{r}
linkMap="https://github.com/EvansDataScience/VAforPM_Spatial/raw/main/worldMap.geojson" # link desde github

library(sf)
mapWorld=read_sf(linkMap)
```
This is the data that came with the map:

```{r, eval=TRUE}
# see data in map
head(mapWorld)
```

Let's add our data to the map data by merging:

```{r, eval=TRUE}
mapWorldVars=merge(mapWorld, #map first
                   dataCSV, 
                   by='ISO3') 
```


You can map the data now using ggplot. Let me do it by layers:

1. Base layer: 

```{r}
library(ggplot2)
# plot original map
base=ggplot(data=mapWorld) + geom_sf(fill='grey90',
                                     color=NA) + theme_classic()

base #base map

```

2. Data layer:

```{r}
colMap= base + geom_sf(data=mapWorldVars,
                       aes(fill=DemoIndex),
                       color=NA)
colMap
```

```{r}
colMap + scale_fill_gradient(low = 'red',
                             high= 'blue')
```


Now paint the countries (ggplot decides color):

```{r}
clusterMap= base + geom_sf(data=mapWorldVars,
                           aes(fill=cluster),
                           color=NA) # color of border
clusterMap 
```

Now you choose the palette (get it from [here](http://colorbrewer2.org/)):

```{r}
clusterMap+ scale_fill_brewer(palette ='YlOrRd')
```


Some more customization:

```{r}
#previously
theLegLabels=c('1_worst',2,'3_best')
theLegTitle="World_Order\n(grey is missing)"

#now
clusterMap+ scale_fill_brewer(palette ='YlOrRd',
                              direction = -1, # color order
                              labels=theLegLabels,
                              name=theLegTitle)
```

Let me bring two data sets on cities:

```{r}
library(rio)

linkCity="https://github.com/Visual-Analytics-Project-UW-EvansSchool/mergedData/raw/main/otherData/citiesloc.xlsx"


idxcity=import(linkCity)

```

The data on cities is known (it is a summary) but this files has some location info:
```{r}
str(idxcity)
```

Let's cluster:

```{r}
varsidx=c("DIGITAL","HEALTH","INFRASTRUCTURE","PERSONAL")

set.seed(123)
distMatrix2=cluster::daisy(idxcity[,varsidx])
             

res.pam2=pam(distMatrix2,
             k = 3,
             cluster.only = F)
                     
idxcity$cluster=res.pam2$clustering

```

Let's check the order:

```{r}

varsidx=c(varsidx,'cluster')
aggregate(data=idxcity[,varsidx],
          .~cluster,
          FUN=median)
```

We could improve the labels:
```{r}
idxcity$cluster=factor(idxcity$cluster,
                       levels=c(3,1,2),
                       labels=c("bad","middle",'good'),
                       ordered=T)
```


Let me use the location of the city to create a spatial object:

```{r}
idxcity_sf = st_as_sf(idxcity, 
                      coords = c("lng", "lat"),
                      crs = st_crs(mapWorldVars)) # shared

```

Now we have:

```{r}
head(idxcity_sf)
```

As this is a spatial object:

```{r}
base + geom_sf(data=idxcity_sf)
```



Finally:

```{r}
#previously
fillLabels=c('1_worst',2,'3_best')
fillTitle="Cities safety"
nameSize="Population \n(in millions)"

points= base + geom_sf(data=idxcity_sf,
                       shape=21,
                       aes(fill=cluster,
                           size=population/1000000)) 
#now
points = points + scale_fill_brewer(palette ='YlOrRd',
                                direction = -1,
                                labels=fillLabels,
                                name=fillTitle)
points =points + scale_size(name=nameSize,
                            range = c(0.2,5))
points
```

We can facet the plotting area:

```{r}
points + facet_wrap(~cluster)
```

Another option is _grid_:

```{r}
points + facet_grid(cluster~.)
```



We can alter the legend position, and eliminate the unneeded legend:

```{r}
points + facet_grid(cluster~.) +
    theme(legend.position="bottom", 
          legend.box = "vertical") + guides(fill=FALSE)
```

Some additional possibilities:
```{r}
points + facet_wrap(cluster~.,ncol = 1) +
    theme(legend.position=c("bottom"),
          legend.box = "vertical",
          strip.text = element_text(size = 8,color='white'),
          strip.background = element_rect(color = NA,
                                          fill='black')
          ) + guides(fill=FALSE)
```

[home](#home)

